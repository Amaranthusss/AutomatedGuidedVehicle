<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Load plotly.js into the DOM -->
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
    <script src="https://www.w3schools.com/lib/w3color.js"></script>
</head>
<body>
    <div class="gnBody">
        <div id='firstPlot'><!-- Plotly chart will be drawn inside this DIV --></div>
        <div id='secondPlot'><!-- Plotly chart will be drawn inside this DIV --></div>
        <button class="menubttn" id="console">Mode: Manual Movements</button><br>
        <button class="menubttn" id="bttn1" onclick="finishLearningMode()">Finish learning mode</button>
        <button class="menubttn" id="bttn2" onclick="autoMode()">Scanners' data</button>
        <button class="menubttn" id="bttn3" onclick="startLearningMode()">Start learning mode</button>
        <button class="menubttn" id="bttn4" onclick="resumeAutoPath()">Resume auto mode and tracking</button>
        <button class="menubttn" id="bttn5" onclick="activeAutoPath()">Active auto mode and do path</button>
        <button class="button" id="forwardButton">FORWARD</button>
        <button class="button" id="backwardButton">BACKWARD</button>
        <button class="button" id="turnLeftButton">TURN LEFT</button>
        <button class="button" id="turnRightButton">TURN RIGHT</button>
        <div class="button" id="pathConsole">
            <label for="pathName">Path Name:</label><br>
            <input type="text" id="pathName" name="pathName"><br>
            <form action="/action_page.php">
                <label for="cars">Choose a car:</label>
                <select name="cars" id="pickingPathName"></select>
                <br>
            </form>
        </div>
        <!--<img class="camWindow" src="http://192.168.8.106:8082/">-->
    </div>

    <!-- JavaScript -->
    <script>

        function finishLearningMode() {
            socket.emit("PATHNAME_" + String(document.getElementById('pathName').value));
            socket.emit("HMI_finishLearningMode");
            document.getElementById("console").innerHTML = "Finished learning mode";
            socket.emit("HMI_refreshPathNamesList");

        }
        function autoMode() {
            //socket.emit("HMI_autoMode");
            //document.getElementById("console").innerHTML = "turned on automode";
            console.log(echoProx)
        }
        function startLearningMode() {
            socket.emit("HMI_startLearningMode");
            document.getElementById("console").innerHTML = "started learning mode";
        }
        function resumeAutoPath() {
            socket.emit("HMI_resumeAutoPath_" + String(document.getElementById("pickingPathName").value));
            document.getElementById("console").innerHTML = "auto mode resumed, path is turned on";
        }
        function activeAutoPath() {
            socket.emit("HMI_activePath_" + String(document.getElementById("pickingPathName").value));
            document.getElementById("console").innerHTML = "auto mode actived, path is turned on";
        }

        { //******************** DIAGRAMS ********************
            //Configuration's data
            const diagTimePeriod = 1000;
            const scannersCoordinates = { fx: 0, fy: 25, bx: 0, by: -25 };
            const diagramsInterval = setInterval(diagrams, diagTimePeriod);
            //Plot Class
            class Plot {
                constructor(plot, trace, layout, echo, timeFcn, repLimit) {
                    //inputs variables
                    this.plot = plot;
                    this.trace = trace;
                    this.layout = layout;
                    this.echo = echo;
                    this.timeFcn = timeFcn;
                    this.repLimit = repLimit;
                    //inner variables
                    this.data = [];
                    this.iniTrace = trace;
                    this.repLimitN = 0;
                }

                push(y, x) { //y is required; x is optional for timeFcn equal true
                    if (this.echo[this.echo.length - 1].distances[this.echo[this.echo.length - 1].distances.length] == 0)
                        this.repLimitN++;
                    else
                        this.repLimitN = 0;
                    //Adding data
                    if (this.repLimitN <= this.repLimit && this.echo[this.echo.length - 1].distances[this.echo.length - 1].dist != NaN) {
                        //Add each point from echo at axis y
                        for (let i = 0; i++ < this.echo[this.echo.length - 1].distances.length;)
                            this.trace.y.push(y);
                        //If this function is in domain of time, estimate axis x
                        if (this.timeFcn == true) //This is function based at time t [ms]
                        {
                            this.trace.x.push(this.repLimitN);
                            this.repLimitN = this.repLimitN + diagTimePeriod / 1000;
                        }
                        else //If it is not, just put x data to axis x
                            this.trace.x.push(x);
                    }
                    this.data = [this.trace];
                    Plotly.newPlot(this.plot, this.data, this.trace);
                }

                clear() {
                    this.data = [];
                    this.trace = this.iniTrace;
                    Plotly.newPlot(this.plot, this.data, this.trace);
                }

                printf() {
                    console.log(
                        this.plot,
                        this.trace,
                        this.data
                    );
                }
            }
            //Diagrams' objects
            const proxTimePlot = new Plot(
                'firstPlot', //Plot name
                { //Trace
                    type: 'scatter',
                    x: [scannersCoordinates.fx, scannersCoordinates.bx],
                    y: [scannersCoordinates.fy, scannersCoordinates.by],
                    mode: 'markers',
                    name: 'd = f(x)',
                    marker: {
                        color: 'rgba(156, 165, 196, 0.95)',
                        line: {
                            color: 'rgba(156, 165, 196, 1.0)',
                            width: 1,
                        },
                        symbol: 'circle',
                        size: 10
                    }
                },
                { //Layout
                    title: 'Dystans w dziedzinie czasu',
                    yaxis2: {
                        domain: [0.6, 0.95],
                        anchor: 'd [cm]'
                    },
                    xaxis2: {
                        domain: [0.6, 0.95],
                        anchor: 't [s]'
                    }
                },
                echoProx, //Echo
                true, //Is that time function?
                5 //Rep limit
            );
            const proxSpacePlot = new Plot(
                'secondPlot', //Plot name
                { //Trace
                    type: 'scatter',
                    x: [scannersCoordinates.fx, scannersCoordinates.bx],
                    y: [scannersCoordinates.fy, scannersCoordinates.by],
                    mode: 'markers',
                    name: 'y = f(x)',
                    marker: {
                        color: 'rgba(156, 165, 196, 0.95)',
                        line: {
                            color: 'rgba(156, 165, 196, 1.0)',
                            width: 1,
                        },
                        symbol: 'circle',
                        size: 10
                    }
                },
                { //Layout
                    title: 'Dystans w uk³adzie przestrzennym',
                    yaxis2: {
                        domain: [0.6, 0.95],
                        anchor: 'y [cm]'
                    },
                    xaxis2: {
                        domain: [0.6, 0.95],
                        anchor: 'x [cm]'
                    }
                },
                echoProx, //Echo
                false, //Is that time function?
                1 //Rep limit
            )
            //Alltime data recived from echo [Socket.io]
            var echoProx = [
                {
                    distances: [],
                    lowest: 0,
                    highest: 0,
                    angle: 0
                }
            ];
            //Events at interval's tick
            function diagrams() {
                //____________ d = f(t) ____________
                proxTimePlot.push(echoProx.distances);
                //____________ y = f(x) ____________
                for (let i = 0; i++;
                    i < echoProx[echoProx.length - 1] //ostatni echoProx
                        .distances[
                    echoProx[echoProx.length - 1].distances.length
                    ]
                ) {
                    proxSpacePlot.push(
                        //Estimate x point [x = X_s + d[n] * sin(a) * PI / 180]
                        diagramsInterval.fx //scanner's offset at axis x
                        + echoProx[echoProx.length - 1].distances[i] //last measured distance
                        * Math.sin(echoProx[echoProx.length - 1].angle //angle at scanner's motor of measurement
                            * Math.PI / 180), //recalculate degrees to radians
                        //Estimate y point [y = Y_s + d[n] * cos(a) * PI / 180]
                        diagramsInterval.fy //scanner's offset at axis y
                        + echoProx[echoProx.length - 1].distances[i] //last measured distance
                        * Math.cos(echoProx[echoProx.length - 1].angle //angle at scanner's motor of measurement
                            * Math.PI / 180) //recalculate degrees to radians
                    );
                }
                
            }

        }

        var socket = io(); //load socket.io-client and connect to the host that serves the page
        window.addEventListener("load", function () { //when page loads

            var forBttn = document.getElementById("forwardButton");
            var backBttn = document.getElementById("backwardButton");
            var leftBttn = document.getElementById("turnLeftButton");
            var rightBttn = document.getElementById("turnRightButton");
            forBttn.addEventListener("mouseup", function () {
                socket.emit("CTRL_forwardStop");
            });
            forBttn.addEventListener("mousedown", function () {
                socket.emit("CTRL_forwardStart");
            });
            backBttn.addEventListener("mouseup", function () {
                socket.emit("CTRL_backwardStop");
            });
            backBttn.addEventListener("mousedown", function () {
                socket.emit("CTRL_backwardStart");
            });
            leftBttn.addEventListener("mouseup", function () {
                socket.emit("CTRL_turnLeftStop");
            });
            leftBttn.addEventListener("mousedown", function () {
                socket.emit("CTRL_turnLeftStart");
            });
            rightBttn.addEventListener("mouseup", function () {
                socket.emit("CTRL_turnRightStop");
            });
            rightBttn.addEventListener("mousedown", function () {
                socket.emit("CTRL_turnRightStart");
            });
        });
        document.onkeydown = checkKeyDown;
        document.onkeyup = checkKeyUp;
        document.addEventListener('keydown', checkKeyDown);


        socket.onevent = function (packet) {
            var str = String(packet.data);
            str = str.split("_");
            document.getElementById("console").innerHTML = str;
            if (str[0] == 'PATHNAMESLIST') {
                var pathNamesList = new Array();
                pathNamesList = str[1].split(",");
                var options = '';
                for (var i = 0; i < pathNamesList.length; i++)
                    options += '<option value="' + pathNamesList[i] + '">' + pathNamesList[i] + '</option>';
                document.getElementById('pickingPathName').innerHTML = options;
            } else if (str[0] == 'VELOCITY') {
                echoData = str[1];
            } else if (str[0] == 'PROXIMITY') {
                if (str[1] != 'undefined') {
                    //proxTimePlot.echo.push(str[1]);
                    proxSpacePlot.echo.push(str[1]);
                    //proxTimePlot.printf();
                    proxSpacePlot.printf();
                }
            }
        };


        function checkKeyDown(e) {

            e = e || window.event;
            if (e.keyCode == '38') {
                // up arrow
                socket.emit("CTRL_forwardStart");
            } else if (e.keyCode == '40') {
                // down arrow
                socket.emit("CTRL_backwardStart");
            } else if (e.keyCode == '37') {
                // left arrow
                socket.emit("CTRL_turnLeftStart");
            } else if (e.keyCode == '39') {
                // right arrow
                socket.emit("CTRL_turnRightStart");
            }

        }

        function checkKeyUp(e) {

            e = e || window.event;
            if (e.keyCode == '38') {
                // up arrow
                socket.emit("CTRL_forwardStop");
            } else if (e.keyCode == '40') {
                // down arrow
                socket.emit("CTRL_backwardStop");
            } else if (e.keyCode == '37') {
                // left arrow
                socket.emit("CTRL_turnLeftStop");
            } else if (e.keyCode == '39') {
                // right arrow
                socket.emit("CTRL_turnRightStop");
            }

        }

    </script>

    <!-- CSS -->
    <style>
        .gnBody {
            position: absolute;
            height: 100%;
            width: 100%;
            left: 0;
            top: 0;
            background-color: #001a33;
        }

        .button {
            position: fixed;
            background-color: black;
            color: white;
            width: 15%;
            height: 15%;
            font-size: 300%;
            border: 2px solid #dadada;
            border-radius: 7px;
            border-color: #9ecaed;
            box-shadow: 0 0 10px #9ecaed;
        }

        .menubttn {
            position: fixed;
            background-color: black;
            color: white;
            font-size: 150%;
            border: 2px solid #dadada;
            border-radius: 7px;
            border-color: #9ecaed;
            box-shadow: 0 0 10px #9ecaed;
        }

        #console {
            display: none;
            left: 0%;
            top: 0%;
            width: 100%;
            height: 5%;
        }

        #bttn1 {
            left: 0%;
            top: 95%;
            width: 20%;
            height: 5%;
        }

        #bttn2 {
            left: 20%;
            top: 95%;
            width: 20%;
            height: 5%;
        }

        #bttn3 {
            left: 40%;
            top: 95%;
            width: 20%;
            height: 5%;
        }

        #bttn4 {
            left: 60%;
            top: 95%;
            width: 20%;
            height: 5%;
        }

        #bttn5 {
            left: 80%;
            top: 95%;
            width: 20%;
            height: 5%;
        }

        #pathConsole {
            display: none;
            left: 10%;
            top: 80%;
            width: 20%;
            height: 8%;
        }

        .camWindow {
            position: fixed;
            top: 6%;
            width: 30%;
            left: 15%;
            border: 2px solid #dadada;
            border-radius: 7px;
            border-color: #9ecaed;
            box-shadow: 0 0 10px #9ecaed;
        }

        #forwardButton {
            display: none;
            left: 62.5%;
            top: 40%;
        }

        #backwardButton {
            display: none;
            left: 62.5%;
            top: 70%;
        }

        #turnLeftButton {
            display: none;
            left: 75%;
            top: 55%;
        }

        #turnRightButton {
            display: none;
            right: 35%;
            top: 55%;
        }
    </style>


</body>
</html>